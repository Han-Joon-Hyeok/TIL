# 2. 선형배열

- 선형 배열은 데이터들이 선처럼 일렬로 늘어선 형태를 말한다. 
- 일반적으로는 배열(array)는 같은 종류의 데이터만 포함한다.
- 하지만 파이썬에서는 서로 다른 종류의 데이터를 담을 수 있다.

## Python 리스트에 활용할 수 있는 연산

### 리스트 길이와 관계없이 빠른 실행 결과를 보이는 연산

- 원소 덧붙이기 : ```.append()```
  - 리스트의 맨 끝에 원소를 추가함.
  - ``` python
    a = [1,2,3]
    a.append(4)
    a
    
    # [1,2,3,4]
    ```
- 원소 하나 꺼내기 : ```.pop()```
  - 리스트의 맨 마지막 원소를 반환하고, 그 원소를 삭제한다. 또는 특정 인덱스를 지정하여 해당 값을 추출할 수 있다.
  - ``` python
    a = [1,2,3]
    a.pop()
    a

    # 3
    # [1,2]

    a = [1,2,3]
    a.pop(1) # 인덱스는 0부터 시작한다.
    a

    # 2
    # [1,3]
    ```
  
### 리스트 길이에 비례해서 실행 시간이 걸리는 연산
- 원소 삽입하기 : ```.insert()```
  - insert(a, b)는 리스트의 a번째 위치에 b를 삽입한다.
  - ``` python
    a = [1,2,3]
    a.insert(1, 5)
    a

    # [1,5,2,3]
    ```
- 원소 삭제하기 : ```.del()```
  - del a[x]는 x번째 원소를 삭제한다. pop과는 달리 삭제하는 값을 반환해주지 않으며, 슬라이싱을 활용해서 여러 개를 삭제할 수도 있다.
  - ``` python
    a = [1,2,3,4,5]
    del a[4]
    a
    
    # [1,2,3,4]

    del a[:1]

    # [2,3,4]
    # 슬라이싱은 [n:m] n번째부터 시작해서 m-1번쨰까지 선택을 한다.
    ```

## 연습문제 1. 정렬된 리스트에 원소 삽입하기.

### 문제설명
> 리스트 L 과 정수 x 가 인자로 주어질 때, 리스트 내의 올바른 위치에 x 를 삽입하여 그 결과 리스트를 반환하는 함수 solution 을 완성하세요. <br><br>
 인자로 주어지는 리스트 L 은 정수 원소들로 이루어져 있으며 크기에 따라 (오름차순으로) 정렬되어 있다고 가정합니다. <br><br>
 예를 들어, L = [20, 37, 58, 72, 91] 이고 x = 65 인 경우, 올바른 리턴 값은 [20, 37, 58, 65, 72, 91] 입니다.

### 내 풀이

``` python
def solution(L, x):
    answer = []
    listLen = len(L)-1
    for i in range(listLen) :
        if x >= L[i] and x <= L[i+1] :
            index = i+1
            L.insert(index,x)
            break
        elif x < L[0] :
            index = 0
            L.insert(index, x)
            break
        elif x > L[-1] :
            index = listLen+1
            L.insert(index, x)
            break

    answer = L

    return answer
```

- n번째 값과 n+1번째 값을 비교함으로써 원소의 위치를 찾고자 하였다.
  - 우선 리스트의 길이를 listLen에 저장하였고, 길이가 n인 리스트에서 n+1번째 원소는 없으므로 -1을 해주어 n번째까지 원소를 비교하도록 하였다.
- 하지만, 값이 가장 작거나, 가장 클 경우는 해결하지 못해서 이를 elif로 처리하였다.
  - index값만 변하는데, 똑같은 코드가 여러 번 작성되어 다소 비효율적인 코드를 작성했다.


### 다른 사람들의 풀이
``` python
    def solution(L, x):

    for idx, num in enumerate(L):
        if num > x :
            L.insert(idx, x)
            break
        elif L[-1] < x :
            L.append(x)
            
    return L
```
- enumerate()라는 함수를 사용해서 간단하게 풀었고, 코드도 깔끔하게 작성되었다.
  - enumerate는 "열거하다"는 뜻을 가졌다.
  - 리스트가 있는 경우, 순서(index)와 리스트의 값(value)을 전달하는 기능이 있다. 
  - 따라서 반복문과 같이 사용하면 리스트를 처음부터 탐색할 수 있게 된다.
  - ``` python
    a = [1,2,3,4]
    for idx, item in enumerate(a) :
        print(idx, item)

    '''
    0 1
    1 2
    2 3
    3 4
    '''
    ```
- 또한 주어진 값이 가장 클 경우에만 elif로 조건을 걸고, append를 활용하여 배열의 맨 마지막에 추가하도록 하였다.

## 연습문제 2. 정렬된 리스트에 원소 삽입

### 문제설명
> 인자로 주어지는 리스트 L 내에서, 또한 인자로 주어지는 원소 x 가 발견되는 모든 인덱스를 구하여 이 인덱스들로 이루어진 리스트를 반환하는 함수 solution 을 완성하세요. <br><br>
 리스트 L 은 정수들로 이루어져 있고 그 순서는 임의로 부여되어 있다고 가정하며, 동일한 원소가 반복하여 들어 있을 수 있습니다. 이 안에 정수 x 가 존재하면 그것들을 모두 발견하여 해당 인덱스들을 리스트로 만들어 반환하고, 만약 존재하지 않으면 하나의 원소로 이루어진 리스트 [-1] 를 반환하는 함수를 완성하세요. <br><br>
 예를 들어, L = [64, 72, 83, 72, 54] 이고 x = 72 인 경우의 올바른 리턴 값은 [1, 3] 입니다. <br><br>
 또 다른 예를 들어, L = [64, 72, 83, 72, 54] 이고 x = 83 인 경우의 올바른 리턴 값은 [2] 입니다. <br><br>
 마지막으로 또 다른 예를 들어, L = [64, 72, 83, 72, 54] 이고 x = 49 인 경우의 올바른 리턴 값은 [-1] 입니다.

### 내 풀이

``` python
def solution(L, x):
    answer = []
    for idx, num in enumerate(L):
        if(x==num):
            answer.append(idx)
        elif x not in L:
            answer.append(-1)
            break
    return answer
```

- 인덱스 값을 찾아야 하기 때문에 연습문제 1에서 배웠던 enumerate 함수를 활용하여 range를 사용하지 않고 문제를 풀었다. 
  - range로도 풀 수는 있지만, 리스트의 길이를 구해줘야 하기 때문에 짧은 코드로는 enumerate가 적합하다.

### 다른 사람들 풀이

``` python
    def solution(L, x):
    
    if x in L :
        return [i for i, n in enumerate(L) if n == x]
    else :
        return [-1]
```

- 조금 더 pythonic하게 코드를 작성했다. return에다가 리스트를 작성함으로써 훨씬 더 짧은 코드가 완성되었다.
  - pythonic한 코드에 대해 조금 더 공부해야겠다.