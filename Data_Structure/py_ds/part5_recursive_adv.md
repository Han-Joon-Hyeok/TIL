# 5강 : 재귀적 이진 탐색 구현

이진 탐색 문제를 재귀적으로 구현하는 문제이다. 빈칸만 채우는 간단한 문제여서 비교적 쉽게 풀 수 있었다.

## 나의 풀이

``` Python
def solution(L, x, l, u):
    if L[l] > x or L[u] < x : # 빈칸 1
        return -1
    mid = (l + u) // 2
    if x == L[mid] :
        return mid
    elif x < L[mid] :
        return solution(L, x, l, mid-1) # 빈칸 2
    else :
        return solution(L, x, mid+1, u) # 빈칸 3
```

- `빈칸 1`
  - 처음에는 `if x not in L`으로 조건을 작성했다. 하지만 이 방법은 재귀적으로 처리할 때마다 **리스트의 모든 원소들을 살펴봐야 하기 떄문에** 효율적이지 못한 방법이다. 실제로 채점을 해보면 정답은 맞지만, 효율성 테스트에서 모두 시간초과로 실패하였다.
  - 그래서 함수가 호출될 떄마다 리스트의 최소값 또는 최대값이 변하므로, 호출되는 당시의 리스트에서 최소값과 최대값 2개만 탐색값과 비교를 했다.
  - 그림으로 살펴보면 다음과 같다.
  ![recursive_bin_search(1)](images/5_recursive_binsearch(1).png) 
  - 리스트에서 탐색값 `x`가 `L[l]`보다 작거나, `L[u]`보다 크면 탐색할 수 없다. 위의 그림에서는 `x = 7`이므로 리스트의 범위를 줄이고 탐색을 진행한다.
  ![recursive_bin_search(2)](images/5_recursive_binsearch(2).png) 
  - 하지만, 이번에는 `L[u] = 6`이므로 리스트의 범위에서 벗어나므로 `-1`을 반환해준다.
- `빈칸 2`와 `빈칸 3`은 이미 이진탐색에서 진행했던 내용을 복습하는 차원이었으므로, 크게 어렵지는 않았다.